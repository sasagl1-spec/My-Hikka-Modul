# meta developer: @kiminaiq
# meta pic: https://img.icons8.com/color/48/000000/yandex.png
# meta description: –ü–∞—Ä—Å–∏–Ω–≥ —Ü–µ–Ω TON –∏ USD –∏–∑ –Ø–Ω–¥–µ–∫—Å.–ü–æ–∏—Å–∫–∞
# scope: hikka_only
# scope: hikka_min 1.6.0

import aiohttp
import asyncio
import time
import re
from datetime import datetime, timedelta
from urllib.parse import quote
from .. import loader, utils
import logging

logger = logging.getLogger(__name__)

@loader.tds
class YandexPriceParser(loader.Module):
    """–ü–∞—Ä—Å–∏–Ω–≥ —Ü–µ–Ω –∏–∑ –Ø–Ω–¥–µ–∫—Å.–ü–æ–∏—Å–∫–∞ –∏ –ø—É–±–ª–∏–∫–∞—Ü–∏—è –≤ –∫–∞–Ω–∞–ª"""
    
    strings = {
        "name": "YandexPriceParser",
        "started": "‚úÖ <b>–ü–∞—Ä—Å–µ—Ä –∑–∞–ø—É—â–µ–Ω!</b>\nüîç –ò—Å—Ç–æ—á–Ω–∏–∫: –Ø–Ω–¥–µ–∫—Å.–ü–æ–∏—Å–∫\nüì¢ –ö–∞–Ω–∞–ª: @priceDollarTon\n‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª: 3 –º–∏–Ω",
        "stopped": "‚èπÔ∏è <b>–ü–∞—Ä—Å–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>",
        "already_running": "‚ö†Ô∏è <b>–ü–∞—Ä—Å–µ—Ä —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç</b>",
        "not_running": "üì≠ <b>–ü–∞—Ä—Å–µ—Ä –Ω–µ –∑–∞–ø—É—â–µ–Ω</b>",
        "test_sent": "üì§ <b>–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω</b>",
        "status": "üîÑ <b>–°—Ç–∞—Ç—É—Å:</b> {}\n‚è∞ <b>–ü–æ—Å–ª–µ–¥–Ω–µ–µ:</b> {}\nüíµ <b>USD:</b> {}‚ÇΩ\nüíé <b>TON:</b> {}‚ÇΩ",
        "error": "‚ùå <b>–û—à–∏–±–∫–∞:</b> {}",
        "parsing": "üîç –ü–∞—Ä—Å–∏–Ω–≥ –Ø–Ω–¥–µ–∫—Å...",
        "parsing_success": "‚úÖ –î–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã",
        "parsing_failed": "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ",
        "no_data": "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
    }
    
    def __init__(self):
        self.task = None
        self.is_running = False
        self.last_update = None
        self.last_usd_price = None
        self.last_ton_price = None
        self.target_channel = "@priceDollarTon"
        self.session = None
        
        # URL –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
        self.urls = {
            "ton": "https://yandex.ru/search/touch/?text={}&lr=1107",
            "usd": "https://yandex.ru/search/touch/?text={}&lr=1107"
        }
        
        # User-Agent –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –º–æ–±–∏–ª—å–Ω–æ–≥–æ –±—Ä–∞—É–∑–µ—Ä–∞
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        }
    
    async def client_ready(self, client, db):
        self.client = client
        self.db = db
        self.session = aiohttp.ClientSession(headers=self.headers)
        logger.info("YandexPriceParser –∑–∞–≥—Ä—É–∂–µ–Ω")
    
    @loader.command(
        ru_doc="–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–∞—Ä—Å–∏–Ω–≥ –∏–∑ –Ø–Ω–¥–µ–∫—Å",
        en_doc="Start parsing from Yandex"
    )
    async def startyandexparse(self, message):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–∞—Ä—Å–∏–Ω–≥"""
        if self.is_running:
            await utils.answer(message, self.strings("already_running"))
            return
        
        self.is_running = True
        self.task = asyncio.create_task(self._parsing_loop())
        
        await utils.answer(message, self.strings("started"))
        logger.info("–ü–∞—Ä—Å–µ—Ä –Ø–Ω–¥–µ–∫—Å –∑–∞–ø—É—â–µ–Ω")
    
    @loader.command(
        ru_doc="–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞—Ä—Å–∏–Ω–≥",
        en_doc="Stop parsing"
    )
    async def stopyandexparse(self, message):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞—Ä—Å–∏–Ω–≥"""
        if not self.is_running:
            await utils.answer(message, self.strings("not_running"))
            return
        
        self.is_running = False
        if self.task:
            self.task.cancel()
            self.task = None
        
        await utils.answer(message, self.strings("stopped"))
        logger.info("–ü–∞—Ä—Å–µ—Ä –Ø–Ω–¥–µ–∫—Å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    
    @loader.command(
        ru_doc="–¢–µ—Å—Ç–æ–≤—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –∏ –ø–æ—Å—Ç",
        en_doc="Test parsing and post"
    )
    async def testyandexparse(self, message):
        """–¢–µ—Å—Ç–æ–≤—ã–π –ø–∞—Ä—Å–∏–Ω–≥"""
        await utils.answer(message, self.strings("parsing"))
        
        try:
            usd_price, ton_price = await self._parse_prices()
            
            if usd_price and ton_price:
                post = self._format_post(usd_price, ton_price)
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –∫–∞–Ω–∞–ª
                await self.client.send_message(
                    self.target_channel,
                    post,
                    parse_mode='HTML'
                )
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
                self.last_usd_price = usd_price
                self.last_ton_price = ton_price
                self.last_update = time.time()
                
                await utils.answer(message, self.strings("test_sent"))
                await message.respond(post, parse_mode='HTML')
            else:
                await utils.answer(message, self.strings("parsing_failed"))
                
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    @loader.command(
        ru_doc="–°—Ç–∞—Ç—É—Å –ø–∞—Ä—Å–µ—Ä–∞",
        en_doc="Parser status"
    )
    async def yandexstatus(self, message):
        """–°—Ç–∞—Ç—É—Å"""
        status = "üü¢ –†–∞–±–æ—Ç–∞–µ—Ç" if self.is_running else "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
        
        last_time = "‚Äî"
        if self.last_update:
            last_time = self._get_msk_time_str(self.last_update)
        
        usd_info = f"{self.last_usd_price:.2f}‚ÇΩ" if self.last_usd_price else self.strings("no_data")
        ton_info = f"{self.last_ton_price:.2f}‚ÇΩ" if self.last_ton_price else self.strings("no_data")
        
        info = self.strings("status").format(status, last_time, usd_info, ton_info)
        await utils.answer(message, info)
    
    @loader.command(
        ru_doc="–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
        en_doc="Force update"
    )
    async def updateyandex(self, message):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å–µ–π—á–∞—Å"""
        await utils.answer(message, self.strings("parsing"))
        
        try:
            usd_price, ton_price = await self._parse_prices()
            
            if usd_price and ton_price:
                post = self._format_post(usd_price, ton_price)
                await message.respond(post, parse_mode='HTML')
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞
                self.last_usd_price = usd_price
                self.last_ton_price = ton_price
                self.last_update = time.time()
            else:
                await utils.answer(message, self.strings("parsing_failed"))
                
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    @loader.command(
        ru_doc="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –Ø–Ω–¥–µ–∫—Å",
        en_doc="Check Yandex availability"
    )
    async def checkyandex(self, message):
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ø–Ω–¥–µ–∫—Å"""
        await utils.answer(message, "üîç –ü—Ä–æ–≤–µ—Ä—è—é –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –Ø–Ω–¥–µ–∫—Å...")
        
        try:
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –≥–ª–∞–≤–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
            async with self.session.get("https://yandex.ru", timeout=10) as response:
                if response.status == 200:
                    await utils.answer(message, "‚úÖ –Ø–Ω–¥–µ–∫—Å –¥–æ—Å—Ç—É–ø–µ–Ω")
                else:
                    await utils.answer(message, f"‚ö†Ô∏è –Ø–Ω–¥–µ–∫—Å –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å {response.status}")
        except Exception as e:
            await utils.answer(message, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")
    
    async def _parsing_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø–∞—Ä—Å–∏–Ω–≥–∞"""
        logger.info("–¶–∏–∫–ª –ø–∞—Ä—Å–∏–Ω–≥–∞ –Ø–Ω–¥–µ–∫—Å –∑–∞–ø—É—â–µ–Ω")
        
        while self.is_running:
            try:
                # –ü–∞—Ä—Å–∏–º —Ü–µ–Ω—ã
                usd_price, ton_price = await self._parse_prices()
                
                if usd_price and ton_price:
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
                    self.last_usd_price = usd_price
                    self.last_ton_price = ton_price
                    self.last_update = time.time()
                    
                    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –ø–æ—Å—Ç
                    post = self._format_post(usd_price, ton_price)
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –∫–∞–Ω–∞–ª
                    await self.client.send_message(
                        self.target_channel,
                        post,
                        parse_mode='HTML'
                    )
                    
                    logger.info(f"–ü–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω | USD: {usd_price:.2f}‚ÇΩ, TON: {ton_price:.2f}‚ÇΩ")
                
                # –ñ–¥–µ–º 3 –º–∏–Ω—É—Ç—ã –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                wait_time = 180  # 3 –º–∏–Ω—É—Ç—ã
                for i in range(wait_time):
                    if not self.is_running:
                        break
                    await asyncio.sleep(1)
                    
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")
                await asyncio.sleep(30)  # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
    
    async def _parse_prices(self):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ü–µ–Ω –∏–∑ –Ø–Ω–¥–µ–∫—Å"""
        try:
            # –ü–∞—Ä—Å–∏–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
            usd_task = asyncio.create_task(self._parse_usd_price())
            ton_task = asyncio.create_task(self._parse_ton_price())
            
            usd_price = await usd_task
            ton_price = await ton_task
            
            return usd_price, ton_price
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")
            return None, None
    
    async def _parse_usd_price(self):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ü–µ–Ω—ã USD"""
        try:
            search_query = "—Ü–µ–Ω–∞ –¥–æ–ª–ª–∞—Ä–∞"
            url = self.urls["usd"].format(quote(search_query))
            
            async with self.session.get(url, timeout=10) as response:
                if response.status == 200:
                    html = await response.text()
                    
                    # –ò—â–µ–º —Ü–µ–Ω—É USD –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö
                    price = self._extract_usd_price_from_html(html)
                    
                    if price:
                        logger.info(f"–¶–µ–Ω–∞ USD –Ω–∞–π–¥–µ–Ω–∞: {price}")
                        return price
            
            # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –ø—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –∑–∞–ø—Ä–æ—Å
            search_query = "–∫—É—Ä—Å –¥–æ–ª–ª–∞—Ä–∞"
            url = self.urls["usd"].format(quote(search_query))
            
            async with self.session.get(url, timeout=10) as response:
                if response.status == 200:
                    html = await response.text()
                    price = self._extract_usd_price_from_html(html)
                    return price
            
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ USD: {e}")
            return None
    
    async def _parse_ton_price(self):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ü–µ–Ω—ã TON"""
        try:
            search_query = "–¶–µ–Ω–∞ —Ç–æ–Ω"
            url = self.urls["ton"].format(quote(search_query))
            
            async with self.session.get(url, timeout=10) as response:
                if response.status == 200:
                    html = await response.text()
                    
                    # –ò—â–µ–º —Ü–µ–Ω—É TON –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö
                    price = self._extract_ton_price_from_html(html)
                    
                    if price:
                        logger.info(f"–¶–µ–Ω–∞ TON –Ω–∞–π–¥–µ–Ω–∞: {price}")
                        return price
            
            # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
            alternative_queries = [
                "TON –∫—É—Ä—Å",
                "Toncoin —Ü–µ–Ω–∞",
                "The Open Network —Ü–µ–Ω–∞",
                "TON —Å—Ç–æ–∏–º–æ—Å—Ç—å"
            ]
            
            for query in alternative_queries:
                url = self.urls["ton"].format(quote(query))
                
                async with self.session.get(url, timeout=10) as response:
                    if response.status == 200:
                        html = await response.text()
                        price = self._extract_ton_price_from_html(html)
                        if price:
                            return price
                
                await asyncio.sleep(1)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
            
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ TON: {e}")
            return None
    
    def _extract_usd_price_from_html(self, html):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ü–µ–Ω—ã USD –∏–∑ HTML"""
        try:
            # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ü–µ–Ω—ã USD
            patterns = [
                r'(\d+[.,]\d+)\s*‚ÇΩ.*[–¥–î]–æ–ª–ª–∞—Ä',
                r'[–¥–î]–æ–ª–ª–∞—Ä.*(\d+[.,]\d+)\s*‚ÇΩ',
                r'USD.*(\d+[.,]\d+)\s*‚ÇΩ',
                r'(\d+[.,]\d+)\s*‚ÇΩ.*USD',
                r'–∫—É—Ä—Å.*–¥–æ–ª–ª–∞—Ä.*(\d+[.,]\d+)',
                r'(\d+)\s*‚ÇΩ\s*–∑–∞\s*–¥–æ–ª–ª–∞—Ä',
                # –î–ª—è –≤–∏–¥–∂–µ—Ç–æ–≤ –Ø–Ω–¥–µ–∫—Å
                r'<span[^>]*>(\d+[.,]\d+)</span>\s*‚ÇΩ.*[–¥–î]–æ–ª–ª–∞—Ä',
                r'data-price="(\d+[.,]\d+)"[^>]*>[–¥–î]–æ–ª–ª–∞—Ä',
                r'<div[^>]*class="[^"]*currency[^"]*"[^>]*>.*?(\d+[.,]\d+).*?</div>'
            ]
            
            for pattern in patterns:
                matches = re.findall(pattern, html, re.IGNORECASE | re.DOTALL)
                for match in matches:
                    try:
                        # –û—á–∏—â–∞–µ–º –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —á–∏—Å–ª–æ
                        price_str = str(match).replace(' ', '').replace(',', '.')
                        price = float(price_str)
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—É–º–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω—ã USD (30-150 —Ä—É–±)
                        if 30 <= price <= 150:
                            return round(price, 2)
                    except (ValueError, AttributeError):
                        continue
            
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è USD: {e}")
            return None
    
    def _extract_ton_price_from_html(self, html):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ü–µ–Ω—ã TON –∏–∑ HTML"""
        try:
            # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ü–µ–Ω—ã TON
            patterns = [
                r'(\d+[.,]\d+)\s*‚ÇΩ.*[T–¢]–æ–Ω',
                r'[T–¢]–æ–Ω.*(\d+[.,]\d+)\s*‚ÇΩ',
                r'Toncoin.*(\d+[.,]\d+)\s*‚ÇΩ',
                r'(\d+[.,]\d+)\s*‚ÇΩ.*Toncoin',
                r'TON.*(\d+[.,]\d+)\s*‚ÇΩ',
                r'(\d+[.,]\d+)\s*‚ÇΩ.*TON',
                r'–∫—É—Ä—Å.*[T–¢]–æ–Ω.*(\d+[.,]\d+)',
                # –î–ª—è –≤–∏–¥–∂–µ—Ç–æ–≤ –Ø–Ω–¥–µ–∫—Å
                r'<span[^>]*>(\d+[.,]\d+)</span>\s*‚ÇΩ.*[T–¢]–æ–Ω',
                r'data-price="(\d+[.,]\d+)"[^>]*>[T–¢]–æ–Ω',
                r'<div[^>]*class="[^"]*cryptocurrency[^"]*"[^>]*>.*?(\d+[.,]\d+).*?</div>'
            ]
            
            for pattern in patterns:
                matches = re.findall(pattern, html, re.IGNORECASE | re.DOTALL)
                for match in matches:
                    try:
                        # –û—á–∏—â–∞–µ–º –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —á–∏—Å–ª–æ
                        price_str = str(match).replace(' ', '').replace(',', '.')
                        price = float(price_str)
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—É–º–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω—ã TON (10-1000 —Ä—É–±)
                        if 10 <= price <= 1000:
                            return round(price, 2)
                    except (ValueError, AttributeError):
                        continue
            
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è TON: {e}")
            return None
    
    def _get_msk_time(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ –ú–°–ö"""
        utc_now = datetime.utcnow()
        msk_time = utc_now + timedelta(hours=3)
        return msk_time
    
    def _get_msk_time_str(self, timestamp=None):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ú–°–ö"""
        if timestamp:
            utc_time = datetime.utcfromtimestamp(timestamp)
            msk_time = utc_time + timedelta(hours=3)
        else:
            msk_time = self._get_msk_time()
        
        return msk_time.strftime("%H:%M –ú–°–ö")
    
    def _format_number(self, number):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–ª–∞"""
        if isinstance(number, (int, float)):
            if number.is_integer():
                return f"{int(number):,}".replace(",", " ")
            else:
                return f"{number:,.2f}".replace(",", " ").replace(".", ",")
        return str(number)
    
    def _format_post(self, usd_price, ton_price):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞"""
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —á–∏—Å–ª–∞
        usd_formatted = self._format_number(usd_price)
        ton_formatted = self._format_number(ton_price)
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –ú–°–ö
        msk_time = self._get_msk_time_str()
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ—Å—Ç
        post = f"üíµ USD: <b>{usd_formatted}‚ÇΩ</b>\n"
        post += f"üíé TON: <b>{ton_formatted}‚ÇΩ</b>\n\n"
        post += f"<i>üïê {msk_time} | @priceDollarTon</i>\n"
        post += f"<i>üîç –ò—Å—Ç–æ—á–Ω–∏–∫: –Ø–Ω–¥–µ–∫—Å.–ü–æ–∏—Å–∫</i>"
        
        return post
    
    async def on_unload(self):
        """–û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ"""
        self.is_running = False
        
        if self.task:
            self.task.cancel()
        
        if self.session:
            await self.session.close()
