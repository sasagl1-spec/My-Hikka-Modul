# meta developer: @kiminaiq
# meta pic: https://img.icons8.com/color/48/000000/wallet--v1.png
# meta description: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã —Å –∫–æ—à–µ–ª—å–∫–æ–º @wallet –∏ –ø—É–±–ª–∏–∫–∞—Ü–∏—è —Ü–µ–Ω TON
# scope: hikka_only
# scope: hikka_min 1.6.0

import asyncio
import time
import re
from datetime import datetime, timedelta
from .. import loader, utils
import logging

logger = logging.getLogger(__name__)

@loader.tds
class WalletAutomation(loader.Module):
    """–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è @wallet: –æ—Ç–∫—Ä—ã—Ç–∏–µ –∫–æ—à–µ–ª—å–∫–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω TON"""
    
    strings = {
        "name": "WalletAutomation",
        "started": "‚úÖ <b>–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞!</b>\nüè¶ –ö–æ—à–µ–ª–µ–∫: @wallet\nüì¢ –ö–∞–Ω–∞–ª: @priceDollarTon\n‚è± –¶–∏–∫–ª: 3 –º–∏–Ω—É—Ç—ã",
        "stopped": "‚èπÔ∏è <b>–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞</b>",
        "already_running": "‚ö†Ô∏è <b>–£–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç</b>",
        "not_running": "üì≠ <b>–ù–µ –∑–∞–ø—É—â–µ–Ω–∞</b>",
        "test_sent": "üì§ <b>–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω</b>",
        "status": "üîÑ <b>–°—Ç–∞—Ç—É—Å:</b> {}\n‚è∞ <b>–ü–æ—Å–ª–µ–¥–Ω–µ–µ:</b> {}\nüí∞ <b>–ë–∞–ª–∞–Ω—Å:</b> {} TON\nüíé <b>–¶–µ–Ω–∞:</b> {}‚ÇΩ",
        "error": "‚ùå <b>–û—à–∏–±–∫–∞:</b> {}",
        "opening_wallet": "üè¶ –û—Ç–∫—Ä—ã–≤–∞—é –∫–æ—à–µ–ª–µ–∫...",
        "getting_prices": "üìä –ü–æ–ª—É—á–∞—é —Ü–µ–Ω—ã...",
        "wallet_ready": "‚úÖ –ö–æ—à–µ–ª–µ–∫ –æ—Ç–∫—Ä—ã—Ç",
        "no_data": "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö",
        "auth_required": "üîê –¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ @wallet",
        "balance_updated": "üí∞ –ë–∞–ª–∞–Ω—Å –æ–±–Ω–æ–≤–ª–µ–Ω"
    }
    
    def __init__(self):
        self.task = None
        self.is_running = False
        self.last_update = None
        self.last_ton_price = None
        self.last_ton_balance = None
        self.wallet_bot = "@wallet"
        self.target_channel = "@priceDollarTon"
        self.wallet_opened = False
        self.session_started = False
        
        # –°–æ—Å—Ç–æ—è–Ω–∏—è –∞–≤—Ç–æ–≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
        self.wallet_state = {
            "authenticated": False,
            "balance_checked": False,
            "prices_checked": False,
            "last_command": None
        }
    
    async def client_ready(self, client, db):
        self.client = client
        self.db = db
        logger.info("WalletAutomation –∑–∞–≥—Ä—É–∂–µ–Ω")
    
    @loader.command(
        ru_doc="–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—é @wallet",
        en_doc="Start @wallet automation"
    )
    async def startwalletauto(self, message):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—é"""
        if self.is_running:
            await utils.answer(message, self.strings("already_running"))
            return
        
        self.is_running = True
        self.task = asyncio.create_task(self._wallet_automation_loop())
        
        await utils.answer(message, self.strings("started"))
        logger.info("–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∫–æ—à–µ–ª—å–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞")
    
    @loader.command(
        ru_doc="–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—é",
        en_doc="Stop automation"
    )
    async def stopwalletauto(self, message):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—é"""
        if not self.is_running:
            await utils.answer(message, self.strings("not_running"))
            return
        
        self.is_running = False
        if self.task:
            self.task.cancel()
            self.task = None
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self.wallet_opened = False
        self.session_started = False
        self.wallet_state = {
            "authenticated": False,
            "balance_checked": False,
            "prices_checked": False,
            "last_command": None
        }
        
        await utils.answer(message, self.strings("stopped"))
        logger.info("–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∫–æ—à–µ–ª—å–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
    
    @loader.command(
        ru_doc="–û—Ç–∫—Ä—ã—Ç—å –∫–æ—à–µ–ª–µ–∫ –≤—Ä—É—á–Ω—É—é",
        en_doc="Open wallet manually"
    )
    async def openwallet(self, message):
        """–û—Ç–∫—Ä—ã—Ç—å –∫–æ—à–µ–ª–µ–∫"""
        await utils.answer(message, self.strings("opening_wallet"))
        
        try:
            # –ù–∞—á–∏–Ω–∞–µ–º —Å–µ—Å—Å–∏—é —Å –∫–æ—à–µ–ª—å–∫–æ–º
            await self._start_wallet_session()
            
            if self.wallet_opened:
                await utils.answer(message, self.strings("wallet_ready"))
            else:
                await utils.answer(message, "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–æ—à–µ–ª–µ–∫")
                
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    @loader.command(
        ru_doc="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å –∏ —Ü–µ–Ω—ã",
        en_doc="Check balance and prices"
    )
    async def checkwallet(self, message):
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ—à–µ–ª–µ–∫"""
        await utils.answer(message, self.strings("getting_prices"))
        
        try:
            ton_balance, ton_price = await self._get_wallet_data()
            
            if ton_balance is not None and ton_price is not None:
                # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ—Å—Ç
                post = self._format_post(ton_price, ton_balance)
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –∫–∞–Ω–∞–ª
                await self.client.send_message(
                    self.target_channel,
                    post,
                    parse_mode='HTML'
                )
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
                self.last_ton_balance = ton_balance
                self.last_ton_price = ton_price
                self.last_update = time.time()
                
                await utils.answer(message, f"‚úÖ –î–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã\n–ë–∞–ª–∞–Ω—Å: {ton_balance} TON\n–¶–µ–Ω–∞: {ton_price}‚ÇΩ")
            else:
                await utils.answer(message, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")
                
        except Exception as e:
            await utils.answer(message, self.strings("error").format(str(e)))
    
    @loader.command(
        ru_doc="–°—Ç–∞—Ç—É—Å –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏",
        en_doc="Automation status"
    )
    async def walletautostatus(self, message):
        """–°—Ç–∞—Ç—É—Å"""
        status = "üü¢ –†–∞–±–æ—Ç–∞–µ—Ç" if self.is_running else "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞"
        
        last_time = "‚Äî"
        if self.last_update:
            last_time = self._get_msk_time_str(self.last_update)
        
        balance_info = f"{self.last_ton_balance} TON" if self.last_ton_balance else self.strings("no_data")
        price_info = f"{self.last_ton_price}‚ÇΩ" if self.last_ton_price else self.strings("no_data")
        
        wallet_state = "‚úÖ –û—Ç–∫—Ä—ã—Ç" if self.wallet_opened else "‚ùå –ó–∞–∫—Ä—ã—Ç"
        auth_state = "‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω" if self.wallet_state["authenticated"] else "‚ùå –ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"
        
        info = f"{self.strings('status').format(status, last_time, balance_info, price_info)}\n\n"
        info += f"üè¶ <b>–°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞:</b>\n"
        info += f"‚Ä¢ {wallet_state}\n"
        info += f"‚Ä¢ {auth_state}\n"
        info += f"‚Ä¢ –ë–∞–ª–∞–Ω—Å –ø—Ä–æ–≤–µ—Ä–µ–Ω: {'‚úÖ' if self.wallet_state['balance_checked'] else '‚ùå'}\n"
        info += f"‚Ä¢ –¶–µ–Ω—ã –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã: {'‚úÖ' if self.wallet_state['prices_checked'] else '‚ùå'}"
        
        await utils.answer(message, info, parse_mode='HTML')
    
    @loader.command(
        ru_doc="–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç —Å —Ç–µ–∫—É—â–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏",
        en_doc="Test post with current data"
    )
    async def testwalletpost(self, message):
        """–¢–µ—Å—Ç–æ–≤—ã–π –ø–æ—Å—Ç"""
        if not self.last_ton_price or not self.last_ton_balance:
            await utils.answer(message, "‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ—Å—Ç–∞")
            return
        
        post = self._format_post(self.last_ton_price, self.last_ton_balance)
        
        await self.client.send_message(
            self.target_channel,
            post,
            parse_mode='HTML'
        )
        
        await utils.answer(message, self.strings("test_sent"))
    
    @loader.command(
        ru_doc="–°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞",
        en_doc="Reset wallet state"
    )
    async def resetwallet(self, message):
        """–°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ"""
        self.wallet_opened = False
        self.session_started = False
        self.wallet_state = {
            "authenticated": False,
            "balance_checked": False,
            "prices_checked": False,
            "last_command": None
        }
        
        await utils.answer(message, "üîÑ –°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞ —Å–±—Ä–æ—à–µ–Ω–æ")
    
    async def _wallet_automation_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –∫–æ—à–µ–ª—å–∫–∞"""
        logger.info("–¶–∏–∫–ª –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –∫–æ—à–µ–ª—å–∫–∞ –∑–∞–ø—É—â–µ–Ω")
        
        while self.is_running:
            try:
                # –®–∞–≥ 1: –û—Ç–∫—Ä—ã–≤–∞–µ–º/–ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—à–µ–ª–µ–∫
                if not self.wallet_opened or not self.wallet_state["authenticated"]:
                    await self._start_wallet_session()
                    await asyncio.sleep(2)
                
                # –®–∞–≥ 2: –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ—à–µ–ª—å–∫–∞
                if self.wallet_opened:
                    ton_balance, ton_price = await self._get_wallet_data()
                    
                    if ton_balance is not None and ton_price is not None:
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
                        self.last_ton_balance = ton_balance
                        self.last_ton_price = ton_price
                        self.last_update = time.time()
                        
                        # –®–∞–≥ 3: –ü—É–±–ª–∏–∫—É–µ–º –ø–æ—Å—Ç
                        post = self._format_post(ton_price, ton_balance)
                        
                        await self.client.send_message(
                            self.target_channel,
                            post,
                            parse_mode='HTML'
                        )
                        
                        logger.info(f"–î–∞–Ω–Ω—ã–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω—ã | –ë–∞–ª–∞–Ω—Å: {ton_balance} TON, –¶–µ–Ω–∞: {ton_price}‚ÇΩ")
                
                # –ñ–¥–µ–º 3 –º–∏–Ω—É—Ç—ã –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
                wait_time = 180  # 3 –º–∏–Ω—É—Ç—ã
                for i in range(wait_time):
                    if not self.is_running:
                        break
                    await asyncio.sleep(1)
                    
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏: {e}")
                await asyncio.sleep(30)  # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
    
    async def _start_wallet_session(self):
        """–ù–∞—á–∞–ª–æ —Å–µ—Å—Å–∏–∏ —Å –∫–æ—à–µ–ª—å–∫–æ–º"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º /start –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
            await self.client.send_message(self.wallet_bot, "/start")
            await asyncio.sleep(2)
            
            # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç
            messages = await self.client.get_messages(self.wallet_bot, limit=3)
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç—ã
            for msg in messages:
                if msg.text:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ç—Ä–µ–±—É–µ—Ç –ª–∏ –±–æ—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                    if any(word in msg.text.lower() for word in ["–≤–æ–π—Ç–∏", "login", "–∞–≤—Ç–æ—Ä–∏–∑", "–ø—Ä–∏–≤–µ—Ç"]):
                        # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É "–û—Ç–∫—Ä—ã—Ç—å –∫–æ—à–µ–ª–µ–∫" –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—É—é
                        if msg.buttons:
                            for row in msg.buttons:
                                for button in row:
                                    if any(word in button.text.lower() for word in ["–∫–æ—à–µ–ª–µ–∫", "wallet", "–æ—Ç–∫—Ä—ã—Ç—å", "open"]):
                                        await button.click()
                                        await asyncio.sleep(2)
                                        self.wallet_opened = True
                                        self.wallet_state["authenticated"] = True
                                        return True
                    
                    # –ï—Å–ª–∏ –±–æ—Ç –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ—à–µ–ª–µ–∫
                    elif any(word in msg.text.lower() for word in ["–±–∞–ª–∞–Ω—Å", "balance", "ton", "–∫–æ—à–µ–ª–µ–∫", "wallet"]):
                        self.wallet_opened = True
                        self.wallet_state["authenticated"] = True
                        return True
            
            # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –∫–Ω–æ–ø–æ–∫, –ø—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—É –Ω–∞–ø—Ä—è–º—É—é
            await self.client.send_message(self.wallet_bot, "–∫–æ—à–µ–ª–µ–∫")
            await asyncio.sleep(2)
            
            await self.client.send_message(self.wallet_bot, "–±–∞–ª–∞–Ω—Å")
            await asyncio.sleep(2)
            
            self.wallet_opened = True
            self.wallet_state["authenticated"] = True
            return True
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–æ—à–µ–ª—å–∫–∞: {e}")
            self.wallet_opened = False
            return False
    
    async def _get_wallet_data(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ—à–µ–ª—å–∫–∞"""
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
            await self.client.send_message(self.wallet_bot, "–±–∞–ª–∞–Ω—Å")
            await asyncio.sleep(2)
            
            await self.client.send_message(self.wallet_bot, "–∫—É—Ä—Å ton")
            await asyncio.sleep(2)
            
            # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç—ã
            messages = await self.client.get_messages(self.wallet_bot, limit=10)
            
            ton_balance = None
            ton_price = None
            
            for msg in messages:
                if msg.text:
                    # –ò—â–µ–º –±–∞–ª–∞–Ω—Å TON
                    if not ton_balance:
                        ton_balance = self._extract_ton_balance(msg.text)
                    
                    # –ò—â–µ–º —Ü–µ–Ω—É TON
                    if not ton_price:
                        ton_price = self._extract_ton_price(msg.text)
                    
                    # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –æ–±–∞ –∑–Ω–∞—á–µ–Ω–∏—è, –≤—ã—Ö–æ–¥–∏–º
                    if ton_balance is not None and ton_price is not None:
                        break
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            self.wallet_state["balance_checked"] = ton_balance is not None
            self.wallet_state["prices_checked"] = ton_price is not None
            
            return ton_balance, ton_price
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ—à–µ–ª—å–∫–∞: {e}")
            return None, None
    
    def _extract_ton_balance(self, text):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ TON"""
        try:
            patterns = [
                r'–±–∞–ª–∞–Ω—Å[:\s]*([\d,]+\.?\d*)\s*ton',
                r'balance[:\s]*([\d,]+\.?\d*)\s*ton',
                r'ton[:\s]*([\d,]+\.?\d*)\s*',
                r'([\d,]+\.?\d*)\s*ton.*–±–∞–ª–∞–Ω—Å',
                r'([\d,]+\.?\d*)\s*ton',
                r'(\d+(?:[.,]\d+)?)\s*toncoin'
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text, re.IGNORECASE)
                if match:
                    balance_str = match.group(1).replace(",", ".")
                    return float(balance_str)
            
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –±–∞–ª–∞–Ω—Å–∞: {e}")
            return None
    
    def _extract_ton_price(self, text):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ü–µ–Ω—ã TON"""
        try:
            patterns = [
                r'ton[:\s]*([\d,]+\.?\d*)\s*‚ÇΩ',
                r'ton[:\s]*([\d,]+\.?\d*)\s*—Ä—É–±',
                r'–∫—É—Ä—Å.*ton[:\s]*([\d,]+\.?\d*)\s*‚ÇΩ',
                r'—Ü–µ–Ω–∞.*ton[:\s]*([\d,]+\.?\d*)\s*‚ÇΩ',
                r'([\d,]+\.?\d*)\s*‚ÇΩ.*ton',
                r'(\d+(?:[.,]\d+)?)\s*—Ä—É–±.*ton'
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text, re.IGNORECASE)
                if match:
                    price_str = match.group(1).replace(",", ".")
                    return float(price_str)
            
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ü–µ–Ω—ã: {e}")
            return None
    
    def _get_msk_time(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ –ú–°–ö"""
        utc_now = datetime.utcnow()
        msk_time = utc_now + timedelta(hours=3)
        return msk_time
    
    def _get_msk_time_str(self, timestamp=None):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ú–°–ö"""
        if timestamp:
            utc_time = datetime.utcfromtimestamp(timestamp)
            msk_time = utc_time + timedelta(hours=3)
        else:
            msk_time = self._get_msk_time()
        
        return msk_time.strftime("%H:%M –ú–°–ö")
    
    def _format_number(self, number):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–ª–∞"""
        if isinstance(number, (int, float)):
            if number.is_integer():
                return f"{int(number):,}".replace(",", " ")
            else:
                return f"{number:,.2f}".replace(",", " ").replace(".", ",")
        return str(number)
    
    def _format_post(self, ton_price, ton_balance):
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞"""
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —á–∏—Å–ª–∞
        price_formatted = self._format_number(ton_price)
        balance_formatted = self._format_number(ton_balance)
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –ú–°–ö
        msk_time = self._get_msk_time_str()
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ—Å—Ç
        post = f"üíé TON: <b>{price_formatted}‚ÇΩ</b>\n"
        post += f"üí∞ –ë–∞–ª–∞–Ω—Å: <b>{balance_formatted} TON</b>\n\n"
        
        if self.last_ton_balance and ton_price:
            total_value = self.last_ton_balance * ton_price
            total_formatted = self._format_number(total_value)
            post += f"üíº –°—Ç–æ–∏–º–æ—Å—Ç—å: <b>{total_formatted}‚ÇΩ</b>\n\n"
        
        post += f"<i>üïê {msk_time} | @priceDollarTon</i>\n"
        post += f"<i>üè¶ –ò—Å—Ç–æ—á–Ω–∏–∫: @wallet</i>"
        
        return post
    
    async def on_unload(self):
        """–û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ"""
        self.is_running = False
        
        if self.task:
            self.task.cancel()
